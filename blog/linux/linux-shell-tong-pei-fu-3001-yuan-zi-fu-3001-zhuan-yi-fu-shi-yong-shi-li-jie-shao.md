#Linux Shell 通配符、元字符、转义符使用实例介绍

###linux shell通配符(wildcard)  

通配符是由`shell`处理的（不是由所涉及到命令语句处理的，其实我们在`shell`各个命令中也没有发现有这些通配符介绍）, 它只会出现在 命令的**“参数”**里（它不用在 命令名称里， 也不用在 操作符上）。当`shell`在**“参数”**中遇到了通配符时，`shell`会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给**“命令”**，然后再由命令进行处理。总之，通配符 实际上就是一种`shell`实现的路径扩展功能。在 通配符被处理后, `shell`会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。

了解了shell通配符，我们现在看下，`shell`常见通配符有那一些了。

**`shell`常见通配符：  ** 

|字符|含义|实例|
|---|---|---|
|*|匹配 0 或多个字符|a*b  a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。|
|?|匹配任意一个字符|a?b  a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。|
|[list]|匹配 list 中的任意单一字符|a[xyz]b   a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。|
|[!list] |匹配 除list 中的任意单一字符|a[!0-9]b  a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。|
|[c1-c2]|匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]|a[0-9]b  0与9之间必须也只能有一个字符 如a0b, a1b... a9b。|
|{string1,string2,...}|匹配 sring1 或 string2 (或更多)其一字符串|a{abc,xyz,123}b    a与b之间只能是abc或xyz或123这三个字符串之一。|  
需要说明的是：**通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为`shell` 特殊代号字符就可。而且涉及的只有`*`,`?`,`[]`,`{}`这几种。**  



###shell元字符（特殊字符 Meta）  

`shell` 除了有通配符之外，由`shell` 负责预先先解析后，将处理结果传给命令行之外，`shell`还有一系列自己的其他特殊字符。 
 
|字符|含义|
|---|---|
|IFS	|由 `<space\>` 或 `<tab>` 或 `<enter>` 三者之一组成(我们常用 space )。|
|CR	|由 `<enter>` 产生。|
|=	|设定变量。|
|$	|作变量或运算替换(请不要与 shell prompt 搞混了)。|
|>	|重导向 stdout。 *|
|<	|重导向 stdin。 *|
|\|	|命令管线。 *|
|&	|重导向 file descriptor ，或将命令置于背境执行。 *|
|( )	|将其内的命令置于 nested subshell 执行，或用于运算或命令替换。 *|
|{ }	|将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。|
|;	|在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 *|
|&&	|在前一个命令结束时，若返回值为 true，继续执行下一个命令。 *|
|\|\|	|在前一个命令结束时，若返回值为 false，继续执行下一个命令。 *|
|!	|执行 history 列表中的命令。*|  

**加入”*” 都是作用在命令名直接。可以看到`shell` 元字符，基本是作用在命令上面，用作多命令分割（或者参数分割）。因此看到与通配符有相同的字符，但是实际上作用范围不同。所以不会出现混淆。**  



###shell转义符  

有时候，我们想让 通配符，或者元字符 变成普通字符，不需要使用它。那么这里我们就需要用到转义符了。 shell提供转义符有三种。  

|字符|说明|
|---|---|
|‘’(单引号)|又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)。|
|“”(双引号)|又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替|
|\\(反斜杠)|又叫转义，去除其后紧跟的元字符或通配符的特殊意义。|  



###shell解析脚本的过程  

看到上面说的这些，想必大家会问到这个问题是，有这么想特殊字符，通配符，那么 `shell`在得到一条命令，到达是怎么样处理的呢？我们看下下面的图：
![]()
如果用双引号包括起来，`shell检`测跳过了1-4步和9-10步，单引号包括起来，`shell`检测就会跳过了1-10步。也就是说，双引号 只经过参数扩展、命令代换和算术代换就可以送入执行步骤，而单引号转义符直接会被送入执行步骤。而且，无论是双引号转义符还是单引号转义符在执行的时候能够告诉各个命令自身内部是一体的，但是其本身在执行时是并不是命令中文本的一部分。