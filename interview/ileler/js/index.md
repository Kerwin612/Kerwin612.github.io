
//////////

# 阐述ArrayList、Vector、LinkedList的存储性能和特性  
`ArrayList`和`Vector`都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，
它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，
`Vector`中的方法由于添加了`synchronized`修饰，因此`Vector`是线程安全的容器，但性能上较`ArrayList`差，
因此已经是`Java`中的遗留容器。`LinkedList`使用**双向链表**实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，
这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
`Vector`属于遗留容器（`Java`早期的版本中提供的容器，除此之外，`Hashtable`、`Dictionary`、`BitSet`、`Stack`、`Properties`都是遗留容器），已经不推荐使用，
但是由于`ArrayList`和`LinkedListed`都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类`Collections`中的`synchronizedList`方法将其转换成
线程安全的容器后再使用（这是对**装潢模式**的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。  

>补充：遗留容器中的`Properties`类和`Stack`类在设计上有严重的问题，`Properties`是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个`Hashtable`并将其两个泛型参数设置为`String`类型，
但是`Java` API中的`Properties`直接继承了`Hashtable`，这很明显是对继承的滥用。这里复用代码的方式应该是`Has-A`关系而不是`Is-A`关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，
使用工具类最好的方式是`Has-A`关系（关联）或`Use-A`关系（依赖）。同理，`Stack`类继承`Vector`也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。

//////////

# List、Map、Set三个接口存取元素时，各有什么特点？  
`List`以特定索引来存取元素，可以有重复元素。`Set`不能存放重复元素（用对象的`equals()`方法来区分元素是否重复）。
`Map`保存键值对（`key-value pair`）映射，映射关系可以是一对一或多对一。
`Set`和`Map`容器都有基于**哈希存储**和**排序树**的两种实现版本，
基于**哈希存储**的版本理论存取时间复杂度为`O(1)`，而基于**排序树**版本的实现在插入或删除元素时会按照元素或元素的键（`key`）构成排序树从而达到排序和去重的效果。